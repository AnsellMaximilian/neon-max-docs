"use strict";(self.webpackChunkneon_max_docs=self.webpackChunkneon_max_docs||[]).push([[7411],{8354:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>r,metadata:()=>a,toc:()=>l});var i=o(4848),n=o(8453);const r={},s="Authorization",a={id:"concepts/authorization",title:"Authorization",description:"Authorization in Neon Max ensures that users can only access resources or perform actions that they are permitted to. It's a way of controlling what authenticated users are allowed to do in the application.",source:"@site/docs/concepts/authorization.md",sourceDirName:"concepts",slug:"/concepts/authorization",permalink:"/neon-max-docs/docs/concepts/authorization",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/concepts/authorization.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Authentication",permalink:"/neon-max-docs/docs/concepts/authentication"},next:{title:"Errors",permalink:"/neon-max-docs/docs/concepts/errors"}},c={},l=[{value:"The <code>Authorization</code> Helper Class",id:"the-authorization-helper-class",level:2},{value:"Policies",id:"policies",level:3},{value:"<code>Authorization.allows()</code>",id:"authorizationallows",level:3},{value:"Rendering a button based on authorization result",id:"rendering-a-button-based-on-authorization-result",level:4},{value:"Redirecting Users Who Fails the Authorization",id:"redirecting-users-who-fails-the-authorization",level:4},{value:"<code>Authorization.allowsFor()</code>",id:"authorizationallowsfor",level:3}];function d(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,n.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"authorization",children:"Authorization"})}),"\n",(0,i.jsx)(t.p,{children:"Authorization in Neon Max ensures that users can only access resources or perform actions that they are permitted to. It's a way of controlling what authenticated users are allowed to do in the application."}),"\n",(0,i.jsxs)(t.h2,{id:"the-authorization-helper-class",children:["The ",(0,i.jsx)(t.code,{children:"Authorization"})," Helper Class"]}),"\n",(0,i.jsxs)(t.p,{children:["Located in ",(0,i.jsx)(t.code,{children:"lib/authorization.ts"}),", the Authorization class is the primary utility for managing access control within Neon Max. It provides a flexible way to enforce permissions by defining and checking policies."]}),"\n",(0,i.jsx)(t.h3,{id:"policies",children:"Policies"}),"\n",(0,i.jsxs)(t.p,{children:["Before diving into the methods under the ",(0,i.jsx)(t.code,{children:"Authorization"})," class, the concept of policies should be made."]}),"\n",(0,i.jsx)(t.p,{children:"Policies define what actions a user can take. They are implemented as functions that take a User object as the first argument and any additional necessary parameters. Policies return a boolean indicating whether the action is permitted."}),"\n",(0,i.jsxs)(t.p,{children:["Policies are registered inside the ",(0,i.jsx)(t.code,{children:"config/authorization.ts"})," file as a property of the ",(0,i.jsx)(t.code,{children:"AUTHORIZATIONS"})," constant variable."]}),"\n",(0,i.jsxs)(t.p,{children:["For example, a policy named ",(0,i.jsx)(t.code,{children:'"can-edit-blog"'})," might check if the current user is the author of a blog post before allowing them to edit it:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:'import { getBlogById } from "@/actions/blog";\r\nimport { User } from "next-auth";\r\n\r\nexport const AUTHORIZATIONS: Record<\r\n  string,\r\n  (user: User, ...args: any[]) => Promise<boolean>\r\n> = {\r\n  "can-edit-blog": async (user, blogId: number) => {\r\n    const blog = await getBlogById(blogId);\r\n\r\n    if (blog && blog.authorId === user.id) return true;\r\n\r\n    return false;\r\n  },\r\n};\n'})}),"\n",(0,i.jsx)(t.h3,{id:"authorizationallows",children:(0,i.jsx)(t.code,{children:"Authorization.allows()"})}),"\n",(0,i.jsx)(t.p,{children:"The Authorization.allows() method is used to check if the currently authenticated user is allowed to perform a specific action based on the defined policies."}),"\n",(0,i.jsx)(t.p,{children:"Parameters:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"policyName"}),": The name of the policy to check."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"...args"}),": Additional arguments required by the policy."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Returns: ",(0,i.jsx)(t.code,{children:"true"})," if the action is allowed, otherwise ",(0,i.jsx)(t.code,{children:"false"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Here's how you would use the previously defined ",(0,i.jsx)(t.code,{children:"can-edit-blog"})," policy using the ",(0,i.jsx)(t.code,{children:"allows()"})," method:"]}),"\n",(0,i.jsx)(t.h4,{id:"rendering-a-button-based-on-authorization-result",children:"Rendering a button based on authorization result"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",children:'<div>\r\n{\r\n  (await Authorization.allows("can-edit-blog", blog.id)) && (\r\n    <Button>Edit Blog</Button>\r\n  );\r\n}\r\n</div>\n'})}),"\n",(0,i.jsxs)(t.p,{children:['In the code above, I\'m only going to render an "edit" button if, according to the ',(0,i.jsx)(t.code,{children:"can-edit-blog"})," policy, the logged in user's ",(0,i.jsx)(t.code,{children:"id"})," is the same as the blog's ",(0,i.jsx)(t.code,{children:"authorId"}),". Basically, only render the button when the current user is the creator of the blog."]}),"\n",(0,i.jsx)(t.h4,{id:"redirecting-users-who-fails-the-authorization",children:"Redirecting Users Who Fails the Authorization"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:'if (!(await Authorization.allows("is-admin"))) {\r\n  redirect("/dashboard");\r\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["In the above example, if a user doesn't pass the ",(0,i.jsx)(t.code,{children:"is-admin"})," authorization, they will be redirected to a dashboard page."]}),"\n",(0,i.jsx)(t.h3,{id:"authorizationallowsfor",children:(0,i.jsx)(t.code,{children:"Authorization.allowsFor()"})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"Authorization.allowsFor()"})," method is similar to ",(0,i.jsx)(t.code,{children:"allows()"}),", but it allows you to check permissions for a specific user rather than the currently authenticated user."]}),"\n",(0,i.jsx)(t.p,{children:"Parameters:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"policyName"}),": The name of the policy to check."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"user"}),": The ",(0,i.jsx)(t.code,{children:"User"})," object representing the user to check permissions for. Unlike ",(0,i.jsx)(t.code,{children:"allows"})," you have to provide this explicitly."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"...args"}),": Additional arguments required by the policy."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Returns: ",(0,i.jsx)(t.code,{children:"true"})," if the action is allowed, otherwise ",(0,i.jsx)(t.code,{children:"false"}),"."]})]})}function h(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,t,o)=>{o.d(t,{R:()=>s,x:()=>a});var i=o(6540);const n={},r=i.createContext(n);function s(e){const t=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:s(e.components),i.createElement(r.Provider,{value:t},e.children)}}}]);