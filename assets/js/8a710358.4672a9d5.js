"use strict";(self.webpackChunkneon_max_docs=self.webpackChunkneon_max_docs||[]).push([[1390],{4512:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>a,toc:()=>c});var s=n(4848),r=n(8453);const o={sidebar_position:3},i="Example Site",a={id:"example-site",title:"Example Site",description:"Neon Max comes packaged with an example blog application that you can go through to get familiar with all the tools that comes with the starter kit as well as Neon Max's own unique functionalities and helpers. This section will help you go through the example application and explain each parts.",source:"@site/docs/example-site.md",sourceDirName:".",slug:"/example-site",permalink:"/neon-max-docs/docs/example-site",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/example-site.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Getting Started",permalink:"/neon-max-docs/docs/getting-started"},next:{title:"Setting Up Neon",permalink:"/neon-max-docs/docs/setting-up-neon"}},l={},c=[{value:"The Blog Site",id:"the-blog-site",level:2},{value:"Structure",id:"structure",level:2},{value:"Models",id:"models",level:2},{value:"Code",id:"code",level:2},{value:"Server Actions",id:"server-actions",level:3},{value:"Authorization and Policy",id:"authorization-and-policy",level:3},{value:"Protected Page",id:"protected-page",level:3},{value:"Validation and <code>Errors</code> Helper",id:"validation-and-errors-helper",level:3},{value:"Client Component",id:"client-component",level:3},{value:"Prisma Type Extraction",id:"prisma-type-extraction",level:4},{value:"<code>useSession</code> to Get Session User in Client Components",id:"usesession-to-get-session-user-in-client-components",level:4}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"example-site",children:"Example Site"})}),"\n",(0,s.jsx)(t.p,{children:"Neon Max comes packaged with an example blog application that you can go through to get familiar with all the tools that comes with the starter kit as well as Neon Max's own unique functionalities and helpers. This section will help you go through the example application and explain each parts."}),"\n",(0,s.jsx)(t.h2,{id:"the-blog-site",children:"The Blog Site"}),"\n",(0,s.jsx)(t.p,{children:"The example website is pretty simple. It's basically a blog app where authenticated users can view, create, update, and delete blogs (or blog posts). It comes with implementations of Neon Max's Authorization helper, so only creators of a blog (blog post) can manipulate it (delete, update, etc.)."}),"\n",(0,s.jsx)(t.h2,{id:"structure",children:"Structure"}),"\n",(0,s.jsxs)(t.p,{children:["All the example code are included inside ",(0,s.jsx)(t.code,{children:"app/examples/blog"}),". There are four pages:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"app/examples/blog/page.tsx"})," \u2192 A list of all the blogs created by users."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"app/examples/blog/create/page.tsx"})," \u2192 A page for users to create their blogs."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"app/examples/blog/[id]/page.tsx"})," \u2192 A detail view of a particular blog post. This is where comments of a blog is shown and created."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"app/examples/blog/[id]/edit/page.tsx"})," \u2192 A page for users to update/edit theri blog."]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"models",children:"Models"}),"\n",(0,s.jsxs)(t.p,{children:["To support the functionalities of the example site, under ",(0,s.jsx)(t.code,{children:"prisma/schema.prisma"}),", you will se some existing models:"]}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"User"})," \u2192 An important model used for authentication. Also used to determine the creator of a particular blog."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"Blog"})," \u2192 The blog itself."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.code,{children:"Comment"})," \u2192 For comments associated with a blog. Each blog has many comments."]}),"\n"]}),"\n",(0,s.jsx)(t.h2,{id:"code",children:"Code"}),"\n",(0,s.jsx)(t.h3,{id:"server-actions",children:"Server Actions"}),"\n",(0,s.jsxs)(t.p,{children:["At ",(0,s.jsx)(t.code,{children:"app/examples/blog/page.tsx"})," you can see an example of a server action... in action!"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'import { getBlogs } from "@/actions/blog";\r\n\r\nconst blogs = await getBlogs();\n'})}),"\n",(0,s.jsxs)(t.p,{children:["And if I go to ",(0,s.jsx)(t.code,{children:"actions/blog"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'"use server";\r\n\r\n// Retrieve all blogs\r\nexport async function getBlogs(): Promise<Blog[]> {\r\n  const blogs = await prisma.blog.findMany({\r\n    include: {\r\n      author: true,\r\n    },\r\n    orderBy: {\r\n      createdAt: "desc",\r\n    },\r\n  });\r\n  return blogs;\r\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["As indicated by ",(0,s.jsx)(t.code,{children:'"use server"'}),", the exported functions in this file are server actions. This means the code runs on the server; that's why I can safely access prisma here. Also because this is a server component, I can immediately use the ",(0,s.jsx)(t.code,{children:"blogs"})," variable and render the contents in the same ",(0,s.jsx)(t.code,{children:"app/examples/blog/page.tsx"})," file."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:'<div className="bg-white shadow-sm rounded-lg">\r\n  {blogs.length === 0 ? (\r\n    <p className="text-gray-500">\r\n      No blogs available. Please create a new one.\r\n    </p>\r\n  ) : (\r\n    <ul className="flex flex-col gap-2 ">\r\n      {blogs.map(async (blog) => (\r\n        <li key={blog.id} className="p-4 border border-gray-200 rounded-md ">\r\n          <div className="flex justify-between items-center">\r\n            <div>\r\n              <h2 className="text-lg font-semibold text-gray-800">\r\n                {blog.title}\r\n              </h2>\r\n              <p className="text-gray-600 text-sm">\r\n                {blog.content.substring(0, 100)}...\r\n              </p>\r\n            </div>\r\n            <div className="flex space-x-3">\r\n              <Link\r\n                href={`/examples/blog/${blog.id}`}\r\n                className={cn(\r\n                  buttonVariants({ variant: "outline", size: "icon" })\r\n                )}\r\n              >\r\n                <Eye className="h-4 w-4" />\r\n              </Link>\r\n\r\n              {(await Authorization.allows("can-edit-blog", blog.id)) && (\r\n                <>\r\n                  <Link\r\n                    href={`/examples/blog/${blog.id}/edit`}\r\n                    className={cn(\r\n                      buttonVariants({ variant: "outline", size: "icon" })\r\n                    )}\r\n                  >\r\n                    <Pencil className="h-4 w-4" />\r\n                  </Link>\r\n                  <form action={handleDelete} className="inline-block">\r\n                    <input type="hidden" name="id" value={blog.id} />\r\n                    <Button type="submit" variant="destructive" size="icon">\r\n                      <Trash className="h-4 w-4" />\r\n                    </Button>\r\n                  </form>\r\n                </>\r\n              )}\r\n            </div>\r\n          </div>\r\n        </li>\r\n      ))}\r\n    </ul>\r\n  )}\r\n</div>\n'})}),"\n",(0,s.jsx)(t.h3,{id:"authorization-and-policy",children:"Authorization and Policy"}),"\n",(0,s.jsxs)(t.p,{children:["There's a lot to unpack here. Firstly, the authorization check with ",(0,s.jsx)(t.code,{children:"Authorization.allows()"}),". ",(0,s.jsx)(t.code,{children:"Authorization"})," is a helper class that lets you register policies based on the authenticated user. In the example, ",(0,s.jsx)(t.code,{children:'Authorization.allows("can-edit-blog")'})," checks the app's list of policies/authorizations to see if a ",(0,s.jsx)(t.code,{children:'"can-edit-blog"'})," policy exists, and, if it does, does the configured check based on the user."]}),"\n",(0,s.jsxs)(t.p,{children:["If you head over to ",(0,s.jsx)(t.code,{children:"config/authorization.ts"}),", you'll see the list of preconfigured policies. Right now it only has ",(0,s.jsx)(t.code,{children:'"can-edit-blog"'}),". And that's exatcly what's being used. If ",(0,s.jsx)(t.code,{children:'Authorization.allows("can-edit-blog")'})," returns ",(0,s.jsx)(t.code,{children:"true"}),' for the current authenticated user, it will display the "delete" and "edit" buttons.']}),"\n",(0,s.jsxs)(t.p,{children:["Let's see what this policy is. Inside ",(0,s.jsx)(t.code,{children:"config/authorization.ts"}),", I can see the entry for ",(0,s.jsx)(t.code,{children:'"can-edit-blog"'}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:'export const AUTHORIZATIONS: Record<\r\n  string,\r\n  (user: User, ...args: any[]) => Promise<boolean>\r\n> = {\r\n  "can-edit-blog": async (user, blogId: number) => {\r\n    const blog = await getBlogById(blogId);\r\n\r\n    if (blog && blog.authorId === user.id) return true;\r\n\r\n    return false;\r\n  },\r\n};\n'})}),"\n",(0,s.jsxs)(t.p,{children:["As you can see, this authorization checks if a user is the owner of a blog with the provided id by checking ",(0,s.jsx)(t.code,{children:"user.id"})," with ",(0,s.jsx)(t.code,{children:"blog.authorId"}),". If it doesn't match, it return false. Meaning the user cannot perform the action. This is an example of using the ",(0,s.jsx)(t.code,{children:"Authorization"})," helper class. For more information on it, go to the ",(0,s.jsx)(t.a,{href:"/docs/concepts/authorization",children:'"authorization"'})," section."]}),"\n",(0,s.jsx)(t.h3,{id:"protected-page",children:"Protected Page"}),"\n",(0,s.jsxs)(t.p,{children:["If you head over to ",(0,s.jsx)(t.code,{children:"app/examples/blog/create/page.tsx"}),", you'll find this piece of code:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"await Auth.authenticated();\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This code uses the ",(0,s.jsx)(t.code,{children:"Auth"})," helper class to prevent unaunthenticated users to visit this page. What this method does is check if there's an active session (meaning the current user is logged in), and if there isn't, redirect the user to the login page defined at ",(0,s.jsx)(t.code,{children:"config/auth.ts"}),"."]}),"\n",(0,s.jsxs)(t.h3,{id:"validation-and-errors-helper",children:["Validation and ",(0,s.jsx)(t.code,{children:"Errors"})," Helper"]}),"\n",(0,s.jsxs)(t.p,{children:["In ",(0,s.jsx)(t.code,{children:"app/examples/blog/create/page.tsx"}),", there's a server action directly defined inside the server component:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:'async function handleCreate(formData: FormData) {\r\n  "use server";\r\n  const title = formData.get("title") as string;\r\n  const content = formData.get("content") as string;\r\n\r\n  const validationResult = Errors.validateZod(blogSchema, { title, content });\r\n\r\n  if (!validationResult.error) {\r\n    await createBlog(title, content);\r\n    revalidatePath("/examples/blog");\r\n\r\n    redirect("/examples/blog");\r\n  } else {\r\n    redirect("/examples/blog/create");\r\n  }\r\n}\n'})}),"\n",(0,s.jsxs)(t.p,{children:["This server action calls another server action ",(0,s.jsx)(t.code,{children:"createBlog"}),". It should be noted that the logic inside this server action could've easily have been included right in ",(0,s.jsx)(t.code,{children:"createBlog"}),", but this code is meant to highlight that you can create server actions in many places."]}),"\n",(0,s.jsxs)(t.p,{children:["But the more important part to look at here is the use of the ",(0,s.jsx)(t.code,{children:"Errors"})," helper under ",(0,s.jsx)(t.code,{children:"lib/errors.ts"})," to validate the values from the form to create the blog before passing it over to ",(0,s.jsx)(t.code,{children:"createBlog"}),". As you can see there's the line ",(0,s.jsx)(t.code,{children:"const validationResult = Errors.validateZod(blogSchema, { title, content })"}),". This code takes in a ",(0,s.jsx)(t.code,{children:"zod"})," schema and one or more values to validate against the said schema."]}),"\n",(0,s.jsxs)(t.p,{children:["It should be noted that this helper method should only be called on the server. Under the hood, what this method does is send ",(0,s.jsx)(t.code,{children:"errors"})," cookies, which will have properties based on the schema on which ",(0,s.jsx)(t.code,{children:"validateZod"})," was used."]}),"\n",(0,s.jsxs)(t.p,{children:["For example, the above ",(0,s.jsx)(t.code,{children:"handleCreate"})," action checks if the method returns any error. If it does return an error, ",(0,s.jsx)(t.code,{children:"validateZod"})," will have already set the cookies to be used in the next request and the user will be redirected back to the create blog page. Inside this page, we will anticipate that we might have some ",(0,s.jsx)(t.code,{children:"errors"})," cookies:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:'<ErrorMessage message={Errors.get("title")} className="mt-4" />\r\n<ErrorMessage message={Errors.get("content")} className="mt-4" />\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Neon Max provides a conveniennt component to display errors called ",(0,s.jsx)(t.code,{children:"ErrorMessage"}),". But a more important part of the above code is the use of the ",(0,s.jsx)(t.code,{children:"Errors.get()"})," method. This directly corresponds to the ",(0,s.jsx)(t.code,{children:"validateZod"})," schema method. In the ",(0,s.jsx)(t.code,{children:"handleCreate"})," method, we validate the fields ",(0,s.jsx)(t.code,{children:"name"})," and ",(0,s.jsx)(t.code,{children:"content"})," against a schema. If validation fails on either of those fields, we well get corresponding errors via the ",(0,s.jsx)(t.code,{children:"errors"})," cookies. We can access these error messages with ",(0,s.jsx)(t.code,{children:"Errors.get()"})," as has been used to supply ",(0,s.jsx)(t.code,{children:"ErrorMessage"}),"s message property."]}),"\n",(0,s.jsx)(t.p,{children:"If you fail a validation against the schema, you will see something like this:"}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsx)(t.img,{alt:"Error helper example",src:n(4388).A+"",width:"1040",height:"849"})}),"\n",(0,s.jsx)(t.h3,{id:"client-component",children:"Client Component"}),"\n",(0,s.jsxs)(t.p,{children:["All of the examples so far have been in server components, but in ",(0,s.jsx)(t.code,{children:"app/examples/blog/Comments.ts"}),", you'll find a client component named ",(0,s.jsx)(t.code,{children:"Comments"}),". This component could've very easily been created as a server component but is included to show that client components are also easy to build with."]}),"\n",(0,s.jsx)(t.h4,{id:"prisma-type-extraction",children:"Prisma Type Extraction"}),"\n",(0,s.jsxs)(t.p,{children:["A pretty neat feature by Prisma that should be mention is the ability to extract a type based on a query to the database. The ",(0,s.jsx)(t.code,{children:"comments"})," state is declared as the type:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"Prisma.CommentGetPayload<{\r\n   include: {\r\n   author: {\r\n       select: {\r\n       name: true;\r\n       };\r\n   };\r\n   };\r\n}>[]\n"})}),"\n",(0,s.jsxs)(t.p,{children:["This is a direct reflection of what I use to fill ",(0,s.jsx)(t.code,{children:"setComments"}),":"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"const comments = await getAllComments(blogId);\r\nsetComments(comments);\n"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"getAllComments"})," is a server action:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"// Get all Comments\r\nexport async function getAllComments(blogId: number) {\r\n  const comments = await prisma.comment.findMany({\r\n    where: {\r\n      blogId,\r\n    },\r\n    include: {\r\n      author: {\r\n        select: {\r\n          name: true,\r\n        },\r\n      },\r\n    },\r\n  });\r\n  return comments;\r\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["As you can see the query is the same as the type defined for ",(0,s.jsx)(t.code,{children:"comments"})," state. You get ",(0,s.jsx)(t.code,{children:"CommentGetPayload"})," and provide it with the query you plan to fill that state with. In the example, comments are fetched as well as their corresponding authors, but the author's other fields are not necessary; that's why the query is limited using ",(0,s.jsx)(t.code,{children:"select"})," to only return the author's name."]}),"\n",(0,s.jsxs)(t.h4,{id:"usesession-to-get-session-user-in-client-components",children:[(0,s.jsx)(t.code,{children:"useSession"})," to Get Session User in Client Components"]}),"\n",(0,s.jsxs)(t.p,{children:["This section is just to highlight that you can use NextAuth's ",(0,s.jsx)(t.code,{children:"useSession()"})," to fetch the currently logged in user (if there's any). In the ",(0,s.jsx)(t.code,{children:"Comments"})," component, only ",(0,s.jsx)(t.code,{children:"status"})," (returned from ",(0,s.jsx)(t.code,{children:"useSession"}),") is used to determin if the current user is authenticated. If they are, the form to create comments is displayed; otherwise the user will be prompted to login."]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},4388:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/error-helper-694e0b78385a2405e92fb5819156fe54.PNG"},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>a});var s=n(6540);const r={},o=s.createContext(r);function i(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);